# vector
- 자동으로 동적 할당을 해주는 배열
- `stack` 이 아닌, `heap` 메모리 사용


<br>


### 시간복잡도
- 임의의 위치에 접근 : **O(1)**
    - `v[4]`, `v.at(4)`
    - 임의의 원소에 접근하는 건, 
    배열과 마찬가지로 시작 주소에서 offset만큼 연산해서 접근하기 때문에 O(1)

- 임의의 위치에 원소 추가 및 제거 : **O(n)**
    - `v.insert(v.begin() + 1, 100)`, `v.erase(v.begin() + 1)`
    - 특정 인덱스에 원소를 추가하거나 제거 시,
    연속적인 메모리를 가져야 하기 때문에 **그 뒤에 데이터 전부를 한 칸씩 옮겨주는 작업**이 필요 → O(n)

- 맨 뒤 위치에 원소 추가 및 제거 : **amortized O(1)**
    - `v.push_back(100)` , `v.pop_back()`
    - 맨 뒤에 추가 또는 제거 시, 그 뒤에는 아무 원소가 없기 때문에 한 칸씩 옮기는 작업이 필요 x
    - 단, vector는 **ptr**, **size**, **capacity** 특성을 가짐.
    - 만약 추가 또는 제거 시, capacity가 꽉 차게 되면,
    **기존 배열을 전부 메모리 해제하고 새로운 메모리를 할당하여 옮긴다**
    이 경우, O(n)이 발생. 하지만 매우 드물게 일어남


<br>


### vector vs. stack, queue
- 배열의 앞에 숫자를 계속 추가해야 하는 경우, 
vector를 사용하면 O(n)을 계속 반복하기 때문에 비효율적.
stack, queue와 같은 자료구조를 선정해서 O(1)으로 효율적으로 풀어야 한다.